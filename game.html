<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mondrian Balance</title>
    <style>
        :root {
            --bg-color: #f0efe9;
            --line-color: #1a1a1a;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #game-container {
            position: relative;
            box-shadow: 0 20px 50px rgba(0,0,0,0.15);
            background: #fff;
            cursor: crosshair;
            border: 12px solid #1a1a1a;
            transition: transform 0.1s ease-out;
        }

        canvas {
            display: block;
        }

        #overlay {
            position: absolute;
            top: -50px;
            left: 0;
            width: 100%;
            text-align: center;
            pointer-events: none;
        }

        #overlay h1 {
            font-size: 11px;
            letter-spacing: 5px;
            text-transform: uppercase;
            margin: 0;
            font-weight: 400;
            color: #1a1a1a;
            opacity: 0.8;
        }

        .failure-screen {
            position: absolute;
            inset: 0;
            background: rgba(255, 255, 255, 0.98);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            backdrop-filter: blur(10px);
        }

        .failure-screen h2 {
            font-weight: 200;
            letter-spacing: 8px;
            text-transform: uppercase;
            margin-bottom: 20px;
            color: #1a1a1a;
        }

        button {
            padding: 12px 30px;
            background: transparent;
            border: 2px solid #1a1a1a;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        button:hover {
            background: #1a1a1a;
            color: white;
            transform: scale(1.05);
        }

        .status-bar {
            position: absolute;
            bottom: -60px;
            width: 100%;
            text-align: center;
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 3px;
            color: #1a1a1a;
            opacity: 0.5;
        }

        #config-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 260px;
            background: rgba(255,255,255,0.96);
            border: 2px solid #1a1a1a;
            padding: 16px;
            font-size: 11px;
            z-index: 20;
            display: none;
            max-height: 90vh;
            overflow-y: auto;
        }

        #config-panel h3 {
            margin: 0 0 12px 0;
            font-size: 10px;
            letter-spacing: 3px;
            text-transform: uppercase;
            font-weight: 400;
        }

        #config-panel h4 {
            margin: 12px 0 6px 0;
            font-size: 9px;
            letter-spacing: 2px;
            text-transform: uppercase;
            font-weight: 600;
            opacity: 0.6;
        }

        #config-panel label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 4px 0;
            font-size: 10px;
        }

        #config-panel input[type="number"] {
            width: 70px;
            padding: 2px 4px;
            border: 1px solid #ccc;
            font-family: monospace;
            font-size: 10px;
            text-align: right;
        }

        #config-panel .btn-row {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        #config-panel .btn-row button {
            flex: 1;
            padding: 6px 10px;
            font-size: 9px;
        }

        #debug-overlay {
            position: absolute;
            top: 8px;
            left: 8px;
            font-family: monospace;
            font-size: 10px;
            color: rgba(26,26,26,0.6);
            pointer-events: none;
            z-index: 15;
            line-height: 1.5;
            display: none;
        }
    </style>
</head>
<body>

<div id="game-container">
    <div id="overlay">
        <h1>Equilibrium Study No. 2</h1>
    </div>
    <canvas id="gameCanvas"></canvas>
    
    <div id="failure-screen" class="failure-screen">
        <h2>Inertia Reached</h2>
        <p style="font-size: 10px; letter-spacing: 2px; margin-bottom: 25px; opacity: 0.6; text-align: center; line-height: 1.6;">
            THE SYSTEM COLLAPSED INTO RIGIDITY<br>STRUCTURAL FAILURE AT SCALE
        </p>
        <button onclick="resetGame()">Restore Composition</button>
    </div>

    <div class="status-bar">
        Slide Lines • Space: Split (12%+) • Dbl-Click: Merge Same Color • C: Config
    </div>

    <div id="debug-overlay"></div>
</div>

<div id="config-panel">
    <h3>Configuration</h3>
    <h4>Split & Smoothing</h4>
    <label>Ideal Rect Count <input type="number" id="cfg-idealRectCount" step="1" min="1"></label>
    <label>Complexity Penalty <input type="number" id="cfg-complexityPenaltyPerRect" step="0.01" min="0"></label>
    <label>Complexity Tolerance <input type="number" id="cfg-complexityTolerance" step="1" min="0"></label>
    <label>Split Stress <input type="number" id="cfg-splitStressAmount" step="0.01" min="0"></label>
    <label>Stress Decay Rate <input type="number" id="cfg-stressDecayRate" step="0.0001" min="0"></label>
    <label>Split White Chance <input type="number" id="cfg-splitForceWhiteChance" step="0.1" min="0" max="1"></label>
    <label>EMA Rise Rate <input type="number" id="cfg-emaRiseRate" step="0.001" min="0"></label>
    <label>EMA Fall Rate <input type="number" id="cfg-emaFallRate" step="0.001" min="0"></label>
    <div class="btn-row">
        <button onclick="applyConfig()">Apply</button>
        <button onclick="resetConfig()">Reset</button>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const failScreen = document.getElementById('failure-screen');
    const container = document.getElementById('game-container');

    const COLORS = {
        RED: { h: 0, s: 92, l: 48, weight: 2.2 },
        BLUE: { h: 225, s: 80, l: 30, weight: 1.8 },
        YELLOW: { h: 48, s: 95, l: 55, weight: 1.4 },
        WHITE: { h: 45, s: 15, l: 97, weight: 0.4 }
    };

    const SIZE = 600;
    const TOTAL_AREA = SIZE * SIZE;
    const MIN_RECT_DIM = 20;
    const MAX_IMBALANCE_TIME = 5000; 

    // Merging Constants
    const BASE_ALIGN_TOL = 16;   // minor axis wiggle, mostly overlap-driven
    const BASE_EDGE_TOL  = 22;   // how far apart edges can be and still count as touching
    const BASE_MAX_MERGE_AREA = 0.42;

    const DEFAULT_CONFIG = {
        idealRectCount: 8,
        complexityPenaltyPerRect: 0.06,
        complexityTolerance: 1,
        splitStressAmount: 0.10,
        stressDecayRate: 0.0006,
        splitForceWhiteChance: 0.5,
        emaRiseRate: 0.002,
        emaFallRate: 0.012
    };
    let config = { ...DEFAULT_CONFIG };

    let rectangles = [];
    let lines = [];
    let state = {
        isGameOver: false,
        draggedLine: null,
        hoveredLine: null,
        hoveredRect: null,
        mergeCandidate: null,
        lastTime: 0,
        balanceScore: 0,
        rawBalanceScore: 0,
        stressDuration: 0,
        localStress: 0,
        elapsedTime: 0,
        driftScale: 0
    };

    class Rectangle {
        constructor(x, y, w, h, colorKey) {
            this.x = x; this.y = y; this.w = w; this.h = h;
            this.colorKey = colorKey;
            this.renderX = x; this.renderY = y; this.renderW = w; this.renderH = h;
        }
        update() {
            const speed = 0.15;
            this.renderX += (this.x - this.renderX) * speed;
            this.renderY += (this.y - this.renderY) * speed;
            this.renderW += (this.w - this.renderW) * speed;
            this.renderH += (this.h - this.renderH) * speed;
        }
    }

    class Line {
        constructor(pos, type) {
            this.pos = pos; this.type = type; this.renderPos = pos;
        }
        update() {
            this.renderPos += (this.pos - this.renderPos) * 0.15;
        }
    }

    // --- Config Panel ---
    const configPanel = document.getElementById('config-panel');
    const debugOverlay = document.getElementById('debug-overlay');
    let configVisible = false;

    function populateConfigPanel() {
        Object.keys(DEFAULT_CONFIG).forEach(key => {
            const el = document.getElementById('cfg-' + key);
            if (el) el.value = config[key];
        });
    }

    function applyConfig() {
        Object.keys(DEFAULT_CONFIG).forEach(key => {
            const el = document.getElementById('cfg-' + key);
            if (el) config[key] = parseFloat(el.value);
        });
    }

    function resetConfig() {
        config = { ...DEFAULT_CONFIG };
        populateConfigPanel();
    }

    function toggleConfigPanel() {
        configVisible = !configVisible;
        configPanel.style.display = configVisible ? 'block' : 'none';
        debugOverlay.style.display = configVisible ? 'block' : 'none';
        if (configVisible) populateConfigPanel();
    }

    function updateDebugOverlay() {
        if (!configVisible) return;
        const delta = state.rawBalanceScore - state.balanceScore;
        debugOverlay.innerHTML =
            `raw: ${state.rawBalanceScore.toFixed(3)} | smooth: ${state.balanceScore.toFixed(3)} | delta: ${delta >= 0 ? '+' : ''}${delta.toFixed(3)}<br>` +
            `rects: ${rectangles.length} | stress: ${state.localStress.toFixed(3)} | elapsed: ${state.elapsedTime.toFixed(1)}s`;
    }

    function init() {
        canvas.width = SIZE;
        canvas.height = SIZE;
        populateConfigPanel();
        resetGame();
        requestAnimationFrame(gameLoop);
    }

    function resetGame() {
        state = {
            ...state,
            isGameOver: false,
            elapsedTime: 0,
            balanceScore: 0,
            rawBalanceScore: 0,
            stressDuration: 0,
            localStress: 0,
            driftScale: 0
        };
        failScreen.style.display = 'none';
        
        // Opening grid includes obvious merge candidates (reds, whites, yellows)
        rectangles = [
            // Top row (h = 280)
            new Rectangle(0,   0, 230, 280, 'RED'),
            new Rectangle(230, 0, 130, 280, 'RED'),
            new Rectangle(360, 0, 120, 280, 'WHITE'),
            new Rectangle(480, 0, 120, 280, 'WHITE'),
            // Bottom row (h = 320)
            new Rectangle(0,   280, 200, 320, 'WHITE'),
            new Rectangle(200, 280, 160, 320, 'YELLOW'),
            new Rectangle(360, 280, 120, 320, 'YELLOW'),
            new Rectangle(480, 280, 120, 320, 'BLUE')
        ];
        syncLinesFromRects();
    }

    function syncLinesFromRects() {
        lines = [];
        const hLines = new Set(), vLines = new Set();
        rectangles.forEach(r => {
            if (r.y > 2 && r.y < SIZE - 2) hLines.add(Math.round(r.y));
            if (r.x > 2 && r.x < SIZE - 2) vLines.add(Math.round(r.x));
        });
        hLines.forEach(y => lines.push(new Line(y, 'h')));
        vLines.forEach(x => lines.push(new Line(x, 'v')));
    }

    function findMergePartner(c) {
        if (!c) return null;

        const stressBias = Math.min(state.balanceScore / 0.6, 1); // 0 calm → 1 tense
        const edgeTol = BASE_EDGE_TOL + stressBias * 24;
        const overlapFrac = 0.35 - stressBias * 0.18; // min overlap of the shorter span along the shared edge
        const maxMergeArea = TOTAL_AREA * (BASE_MAX_MERGE_AREA + stressBias * 0.30);
        const cArea = c.w * c.h;

        const overlap = (a0, a1, b0, b1) => Math.max(0, Math.min(a1, b1) - Math.max(a0, b0));

        return rectangles.find(r => {
            if (r === c) return false;
            if (r.colorKey !== c.colorKey) return false;

            const rArea = r.w * r.h;
            if ((cArea + rArea) > maxMergeArea) return false;

            const verticalTouch =
                Math.abs((r.y + r.h) - c.y) < edgeTol ||
                Math.abs((c.y + c.h) - r.y) < edgeTol;

            const horizontalTouch =
                Math.abs((r.x + r.w) - c.x) < edgeTol ||
                Math.abs((c.x + c.w) - r.x) < edgeTol;

            // Require meaningful overlap on the perpendicular axis so it feels like a shared edge
            const verticalOverlap = overlap(r.x, r.x + r.w, c.x, c.x + c.w);
            const horizontalOverlap = overlap(r.y, r.y + r.h, c.y, c.y + c.h);

            const spansVertical = verticalTouch &&
                (verticalOverlap >= Math.min(r.w, c.w) * overlapFrac);

            const spansHorizontal = horizontalTouch &&
                (horizontalOverlap >= Math.min(r.h, c.h) * overlapFrac);

            return spansVertical || spansHorizontal;
        });
    }

    function calculateBalance(dt) {
        let totalMass = 0, momentX = 0, momentY = 0;
        rectangles.forEach(r => {
            const mass = (r.w * r.h) * COLORS[r.colorKey].weight;
            totalMass += mass;
            momentX += mass * (r.x + r.w / 2);
            momentY += mass * (r.y + r.h / 2);
        });

        const comX = momentX / totalMass, comY = momentY / totalMass;
        const dist = Math.sqrt(Math.pow(comX - SIZE/2, 2) + Math.pow(comY - SIZE/2, 2));
        const centerPenalty = dist / (SIZE / 5);

        const deviation = Math.abs(rectangles.length - config.idealRectCount);
        const complexityFactor = Math.max(0, deviation - config.complexityTolerance) * config.complexityPenaltyPerRect;

        const targetScore = Math.min(centerPenalty + complexityFactor + state.localStress, 1.2);
        state.rawBalanceScore = targetScore;

        // Asymmetric EMA: rises slowly, falls quickly
        const delta = targetScore - state.balanceScore;
        const rate = delta > 0 ? config.emaRiseRate * dt : config.emaFallRate * dt;
        state.balanceScore += delta * Math.min(rate, 1);

        if (state.balanceScore > 0.75) {
            state.stressDuration += 16.6;
            if (state.stressDuration > MAX_IMBALANCE_TIME) {
                state.isGameOver = true;
                failScreen.style.display = 'flex';
            }
        } else {
            state.stressDuration = Math.max(0, state.stressDuration - 25);
        }
    }

    function update(dt) {
        if (state.isGameOver) return;
        state.elapsedTime += dt / 1000;
        state.localStress = Math.max(0, state.localStress - config.stressDecayRate * dt);

        if (state.elapsedTime > 20) {
            state.driftScale = Math.min(1, (state.elapsedTime - 20) / 120);
            lines.forEach(l => {
                const noise = (Math.random() - 0.5) * state.driftScale * (1 + state.balanceScore);
                moveLine(l, noise * 0.1);
            });
        }

        rectangles.forEach(r => r.update());
        lines.forEach(l => l.update());
        calculateBalance(dt);
    }

    function draw() {
        ctx.fillStyle = '#fdfcf8';
        ctx.fillRect(0, 0, SIZE, SIZE);

        const imb = state.balanceScore;
        const pulse = (Math.sin(state.elapsedTime * 8) + 1) / 2;

        rectangles.forEach(r => {
            const base = COLORS[r.colorKey];
            const s = base.s * (1 - imb * 0.8);
            const l = base.l * (1 - imb * 0.4);
            const breathe = Math.sin(state.elapsedTime * (1 + imb * 2)) * (imb * 4);

            ctx.fillStyle = `hsl(${base.h}, ${s}%, ${l}%)`;
            ctx.fillRect(r.renderX + breathe, r.renderY + breathe, r.renderW, r.renderH);

            // Highlight mergeable areas - Stickier and stronger cue
            if ((state.hoveredRect === r || state.mergeCandidate === r) && state.mergeCandidate) {
                ctx.strokeStyle = `rgba(26,26,26, ${0.35 + pulse * 0.4})`;
                ctx.lineWidth = 6;
                ctx.strokeRect(r.renderX + breathe + 5, r.renderY + breathe + 5, r.renderW - 10, r.renderH - 10);
            }
            
            if (imb > 0.3) {
                const grad = ctx.createRadialGradient(r.renderX+r.renderW/2, r.renderY+r.renderH/2, 0, r.renderX+r.renderW/2, r.renderY+r.renderH/2, r.renderW);
                grad.addColorStop(0, 'transparent');
                grad.addColorStop(1, `rgba(0,0,0,${imb * 0.15})`);
                ctx.fillStyle = grad;
                ctx.fillRect(r.renderX, r.renderY, r.renderW, r.renderH);
            }
        });

        const lineThickness = 6 * (1 + imb * 4);
        lines.forEach(l => {
            const isHover = state.hoveredLine === l || state.draggedLine === l;
            ctx.fillStyle = isHover ? '#ff4d4d' : `rgba(26,26,26,${0.9 + imb * 0.1})`;
            const jitter = (Math.random() - 0.5) * (imb * 2);
            
            if (l.type === 'h') ctx.fillRect(0, l.renderPos - lineThickness/2 + jitter, SIZE, lineThickness);
            else ctx.fillRect(l.renderPos - lineThickness/2 + jitter, 0, lineThickness, SIZE);
        });

        if (state.balanceScore > 0.8) {
            container.style.transform = `translate(${(Math.random()-0.5)*5}px, ${(Math.random()-0.5)*5}px)`;
        } else {
            container.style.transform = 'none';
        }
    }

    function gameLoop(time) {
        const dt = time - state.lastTime;
        state.lastTime = time;
        update(dt);
        draw();
        updateDebugOverlay();
        requestAnimationFrame(gameLoop);
    }

    canvas.addEventListener('mousedown', e => {
        if (state.isGameOver) return;
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left, my = e.clientY - rect.top;
        state.draggedLine = lines.find(l => Math.abs((l.type === 'h' ? my : mx) - l.pos) < 20);
    });

    window.addEventListener('mousemove', e => {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left, my = e.clientY - rect.top;
        
        state.hoveredLine = lines.find(l => Math.abs((l.type === 'h' ? my : mx) - l.pos) < 15);
        
        state.hoveredRect = rectangles.find(r => mx > r.x && mx < r.x + r.w && my > r.y && my < r.y + r.h);
        
        // Sticky merge candidate
        if (state.hoveredRect) {
            const candidate = findMergePartner(state.hoveredRect);
            state.mergeCandidate = candidate || null;
        } else {
            state.mergeCandidate = null;
        }

        if (!state.draggedLine || state.isGameOver) return;
        
        const efficiency = state.balanceScore > 0.75 ? 0.4 : 1.0;
        const pos = state.draggedLine.type === 'h' ? my : mx;
        const delta = (pos - state.draggedLine.pos) * efficiency;
        moveLine(state.draggedLine, delta);
    });

    window.addEventListener('mouseup', () => state.draggedLine = null);

    function moveLine(line, delta) {
        if (Math.abs(delta) < 0.01) return;
        const newPos = Math.max(10, Math.min(SIZE - 10, line.pos + delta));
        const canMove = rectangles.every(r => {
            if (line.type === 'h') {
                if (Math.abs(r.y - line.pos) < 1) return (r.h - (newPos - line.pos)) >= MIN_RECT_DIM;
                if (Math.abs(r.y + r.h - line.pos) < 1) return (r.h + (newPos - line.pos)) >= MIN_RECT_DIM;
            } else {
                if (Math.abs(r.x - line.pos) < 1) return (r.w - (newPos - line.pos)) >= MIN_RECT_DIM;
                if (Math.abs(r.x + r.w - line.pos) < 1) return (r.w + (newPos - line.pos)) >= MIN_RECT_DIM;
            }
            return true;
        });

        if (canMove) {
            const actualDelta = newPos - line.pos;
            rectangles.forEach(r => {
                if (line.type === 'h') {
                    if (Math.abs(r.y - line.pos) < 1) { r.y += actualDelta; r.h -= actualDelta; }
                    else if (Math.abs(r.y + r.h - line.pos) < 1) r.h += actualDelta;
                } else {
                    if (Math.abs(r.x - line.pos) < 1) { r.x += actualDelta; r.w -= actualDelta; }
                    else if (Math.abs(r.x + r.w - line.pos) < 1) r.w += actualDelta;
                }
            });
            line.pos = newPos;
        }
    }

    window.addEventListener('keydown', e => {
        if (e.code === 'Space') { splitTarget(); e.preventDefault(); }
        if (e.code === 'KeyC') { toggleConfigPanel(); }
    });

    function splitTarget() {
        let eligible = rectangles.filter(r => (r.w * r.h) >= (TOTAL_AREA * 0.12));
        if (eligible.length === 0) return;

        let target = eligible.reduce((a, b) => (a.w * a.h > b.w * b.h ? a : b));
        const idx = rectangles.indexOf(target);
        const splitVert = target.w > target.h;
        const splitPoint = 0.5;
        const childColor = Math.random() < config.splitForceWhiteChance ? 'WHITE' : target.colorKey;

        if (splitVert) {
            rectangles.splice(idx, 1,
                new Rectangle(target.x, target.y, target.w * splitPoint, target.h, target.colorKey),
                new Rectangle(target.x + target.w * splitPoint, target.y, target.w * (1-splitPoint), target.h, childColor)
            );
        } else {
            rectangles.splice(idx, 1,
                new Rectangle(target.x, target.y, target.w, target.h * splitPoint, target.colorKey),
                new Rectangle(target.x, target.y + target.h * splitPoint, target.w, target.h * (1-splitPoint), childColor)
            );
        }

        state.localStress += config.splitStressAmount;
        syncLinesFromRects();
    }

    canvas.addEventListener('dblclick', e => {
        if (state.isGameOver) return;
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left, my = e.clientY - rect.top;
        const c = rectangles.find(r => mx > r.x && mx < r.x + r.w && my > r.y && my < r.y + r.h) || state.hoveredRect;
        const n = findMergePartner(c) || state.mergeCandidate;

        if (c && n) {
            const newX = Math.min(c.x, n.x), newY = Math.min(c.y, n.y);
            const newW = Math.max(c.x + c.w, n.x + n.w) - newX;
            const newH = Math.max(c.y + c.h, n.y + n.h) - newY;

            rectangles = rectangles.filter(r => r !== c && r !== n);
            rectangles.push(new Rectangle(newX, newY, newW, newH, c.colorKey));
            
            state.localStress *= 0.6;
            syncLinesFromRects();
            state.hoveredRect = null;
            state.mergeCandidate = null;
        }
    });

    init();
</script>
</body>
</html>
