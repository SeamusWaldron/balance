<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Balance</title>
    <style>
        :root {
            --bg-color: #f0efe9;
            --line-color: #1a1a1a;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #game-container {
            position: relative;
            box-shadow: 0 20px 50px rgba(0,0,0,0.15);
            background: #fff;
            cursor: crosshair;
            border: 12px solid #1a1a1a;
            transition: transform 0.1s ease-out;
        }

        canvas {
            display: block;
        }

        #overlay {
            position: absolute;
            top: -50px;
            left: 0;
            width: 100%;
            text-align: center;
            pointer-events: none;
        }

        #overlay h1 {
            font-size: 11px;
            letter-spacing: 5px;
            text-transform: uppercase;
            margin: 0;
            font-weight: 400;
            color: #1a1a1a;
            opacity: 0.8;
        }

        .failure-screen {
            position: absolute;
            inset: 0;
            background: rgba(255, 255, 255, 0.98);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            backdrop-filter: blur(10px);
        }

        .failure-screen h2 {
            font-weight: 200;
            letter-spacing: 8px;
            text-transform: uppercase;
            margin-bottom: 20px;
            color: #1a1a1a;
        }

        button {
            padding: 12px 30px;
            background: transparent;
            border: 2px solid #1a1a1a;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        button:hover {
            background: #1a1a1a;
            color: white;
            transform: scale(1.05);
        }

        .status-bar {
            position: absolute;
            bottom: -60px;
            width: 100%;
            text-align: center;
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 3px;
            color: #1a1a1a;
            opacity: 0.5;
        }

        #debug-panel {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.85);
            color: #0f0;
            font-family: monospace;
            font-size: 11px;
            padding: 12px;
            border-radius: 4px;
            min-width: 220px;
            z-index: 1000;
            display: none;
        }
        #debug-panel.visible { display: block; }
        #debug-panel h3 {
            margin: 0 0 8px 0;
            color: #fff;
            font-size: 12px;
            border-bottom: 1px solid #444;
            padding-bottom: 4px;
        }
        #debug-panel .row {
            display: flex;
            justify-content: space-between;
            margin: 3px 0;
        }
        #debug-panel .label { color: #aaa; }
        #debug-panel .value { color: #0f0; }
        #debug-panel .warning { color: #ff0; }
        #debug-panel .danger { color: #f00; }
        #debug-panel .stable { color: #0f0; }
        #debug-panel .bar {
            height: 8px;
            background: #333;
            margin: 4px 0;
            border-radius: 2px;
            overflow: hidden;
        }
        #debug-panel .bar-fill {
            height: 100%;
            transition: width 0.1s, background 0.3s;
        }

        /* Gallery overlay for saved compositions */
        #gallery-overlay {
            position: fixed;
            inset: 0;
            background: rgba(240, 239, 233, 0.98);
            z-index: 2000;
            display: none;
            flex-direction: column;
            align-items: center;
            padding: 40px;
            overflow-y: auto;
        }
        #gallery-overlay.visible { display: flex; }
        #gallery-overlay h2 {
            font-weight: 200;
            letter-spacing: 6px;
            text-transform: uppercase;
            margin-bottom: 30px;
            color: #1a1a1a;
        }
        .gallery-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 20px;
            width: 100%;
            max-width: 900px;
        }
        .gallery-item {
            background: #fff;
            border: 3px solid #1a1a1a;
            padding: 10px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .gallery-item:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.15);
        }
        .gallery-item canvas {
            width: 100%;
            aspect-ratio: 1;
            display: block;
        }
        .gallery-item .meta {
            margin-top: 8px;
            font-size: 9px;
            letter-spacing: 1px;
            color: #666;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .gallery-item .delete-btn {
            background: none;
            border: none;
            color: #999;
            cursor: pointer;
            font-size: 14px;
            padding: 2px 6px;
        }
        .gallery-item .delete-btn:hover { color: #c00; }
        .gallery-close {
            position: fixed;
            top: 20px;
            right: 30px;
            background: none;
            border: 2px solid #1a1a1a;
            padding: 8px 16px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-size: 11px;
        }
        .gallery-empty {
            color: #999;
            font-style: italic;
            letter-spacing: 2px;
        }
        .save-toast {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: #1a1a1a;
            color: #fff;
            padding: 12px 24px;
            font-size: 11px;
            letter-spacing: 2px;
            text-transform: uppercase;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 3000;
        }
        .save-toast.visible { opacity: 1; }

        /* Config panel */
        #config-panel {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.92);
            color: #fff;
            font-family: monospace;
            font-size: 10px;
            padding: 15px;
            border-radius: 4px;
            width: 280px;
            max-height: 90vh;
            overflow-y: auto;
            z-index: 1001;
            display: none;
        }
        #config-panel.visible { display: block; }
        #config-panel h3 {
            margin: 0 0 10px 0;
            color: #0ff;
            font-size: 11px;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
        }
        #config-panel h4 {
            margin: 12px 0 6px 0;
            color: #ff0;
            font-size: 10px;
        }
        #config-panel .config-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 4px 0;
        }
        #config-panel label {
            color: #aaa;
            flex: 1;
        }
        #config-panel input[type="number"] {
            width: 60px;
            background: #222;
            border: 1px solid #444;
            color: #0f0;
            padding: 3px 5px;
            font-family: monospace;
            font-size: 10px;
        }
        #config-panel input[type="number"]:focus {
            outline: none;
            border-color: #0ff;
        }
        #config-panel .btn-row {
            display: flex;
            gap: 8px;
            margin-top: 15px;
        }
        #config-panel button {
            flex: 1;
            padding: 8px;
            background: #333;
            border: 1px solid #555;
            color: #fff;
            cursor: pointer;
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        #config-panel button:hover {
            background: #444;
            border-color: #0ff;
        }
        #config-panel button.primary {
            background: #0a5;
            border-color: #0c7;
        }
        #config-panel button.primary:hover {
            background: #0b6;
        }
    </style>
</head>
<body>

<div id="game-container">
    <div id="overlay">
        <h1>Equilibrium Study No. 2</h1>
    </div>
    <canvas id="gameCanvas"></canvas>

    <div id="failure-screen" class="failure-screen">
        <h2>Inertia Reached</h2>
        <p style="font-size: 10px; letter-spacing: 2px; margin-bottom: 25px; opacity: 0.6; text-align: center; line-height: 1.6;">
            THE SYSTEM COLLAPSED INTO RIGIDITY<br>STRUCTURAL FAILURE AT SCALE
        </p>
        <button id="restart-btn">Restore Composition</button>
    </div>

    <div class="status-bar">
        Space: Split &bull; Dbl-Click: Merge &bull; S: Save &bull; G: Gallery &bull; C: Config
    </div>
</div>

<div id="debug-panel">
    <h3>Debug Panel (D to toggle)</h3>
    <div class="row"><span class="label">Time:</span><span class="value" id="dbg-time">0.0s</span></div>
    <div class="row"><span class="label">Band:</span><span class="value" id="dbg-band">STABLE</span></div>
    <div class="row"><span class="label">Balance:</span><span class="value" id="dbg-balance">0.00</span></div>
    <div class="bar"><div class="bar-fill" id="dbg-balance-bar" style="width:0%;background:#0f0;"></div></div>
    <div class="row"><span class="label">Raw Balance:</span><span class="value" id="dbg-raw">0.00</span></div>
    <div class="row"><span class="label">Drift Scale:</span><span class="value" id="dbg-drift">0.00</span></div>
    <div class="row"><span class="label">Stress Duration:</span><span class="value" id="dbg-stress">0ms</span></div>
    <div class="row"><span class="label">COM Offset:</span><span class="value" id="dbg-com">0px</span></div>
    <div class="row"><span class="label">Rectangles:</span><span class="value" id="dbg-rects">0</span></div>
    <div class="row"><span class="label">Avg Local Stress:</span><span class="value" id="dbg-local">0.00</span></div>
    <div class="row"><span class="label">Compression:</span><span class="value" id="dbg-compress">0.00</span></div>
    <h3 style="margin-top:10px;">Color Areas</h3>
    <div class="row"><span class="label">RED:</span><span class="value" id="dbg-red">0%</span></div>
    <div class="row"><span class="label">BLUE:</span><span class="value" id="dbg-blue">0%</span></div>
    <div class="row"><span class="label">YELLOW:</span><span class="value" id="dbg-yellow">0%</span></div>
    <div class="row"><span class="label">WHITE:</span><span class="value" id="dbg-white">0%</span></div>
</div>

<div id="gallery-overlay">
    <button class="gallery-close" id="gallery-close">Close (Esc)</button>
    <h2>Saved Compositions</h2>
    <div class="gallery-grid" id="gallery-grid"></div>
</div>

<div class="save-toast" id="save-toast">Composition Saved</div>

<div id="config-panel">
    <h3>Config Panel (C to toggle)</h3>

    <h4>Balance Weights</h4>
    <div class="config-row"><label>Color:</label><input type="number" id="cfg-w-color" step="0.05" min="0" max="1"></div>
    <div class="config-row"><label>COM:</label><input type="number" id="cfg-w-com" step="0.05" min="0" max="1"></div>
    <div class="config-row"><label>Edge:</label><input type="number" id="cfg-w-edge" step="0.05" min="0" max="1"></div>
    <div class="config-row"><label>Complexity:</label><input type="number" id="cfg-w-complexity" step="0.05" min="0" max="1"></div>
    <div class="config-row"><label>Compression:</label><input type="number" id="cfg-w-compress" step="0.05" min="0" max="1"></div>

    <h4>State Bands</h4>
    <div class="config-row"><label>Stable max:</label><input type="number" id="cfg-band-stable" step="0.02" min="0" max="1"></div>
    <div class="config-row"><label>Tension max:</label><input type="number" id="cfg-band-tension" step="0.02" min="0" max="1"></div>
    <div class="config-row"><label>Warning max:</label><input type="number" id="cfg-band-warning" step="0.02" min="0" max="1"></div>

    <h4>Drift Settings</h4>
    <div class="config-row"><label>Start time (s):</label><input type="number" id="cfg-drift-start" step="1" min="0" max="60"></div>
    <div class="config-row"><label>Ramp time (s):</label><input type="number" id="cfg-drift-ramp" step="5" min="10" max="300"></div>
    <div class="config-row"><label>Min factor:</label><input type="number" id="cfg-drift-min" step="0.05" min="0" max="1"></div>
    <div class="config-row"><label>Max factor:</label><input type="number" id="cfg-drift-max" step="0.1" min="0.5" max="5"></div>

    <h4>Timing</h4>
    <div class="config-row"><label>Collapse time (ms):</label><input type="number" id="cfg-collapse-time" step="500" min="1000" max="30000"></div>
    <div class="config-row"><label>Ideal rect count:</label><input type="number" id="cfg-ideal-rects" step="1" min="3" max="15"></div>

    <div class="btn-row">
        <button id="cfg-reset">Reset Defaults</button>
        <button id="cfg-apply" class="primary">Apply</button>
    </div>
</div>

<script>
(function() {
    'use strict';

    // === CONSTANTS ===
    const SIZE = 600;
    const TOTAL_AREA = SIZE * SIZE;
    const MIN_RECT_DIM = 20;

    // === CONFIGURABLE SETTINGS ===
    const DEFAULT_CONFIG = {
        // Balance weights
        wColor: 0.35,
        wCom: 0.20,
        wEdge: 0.20,
        wComplexity: 0.25,
        wCompression: 0.25,
        // State bands
        bandStable: 0.48,
        bandTension: 0.58,
        bandWarning: 0.68,
        // Drift
        driftStartTime: 8,
        driftRampTime: 90,
        driftMinFactor: 0.1,
        driftMaxFactor: 2.5,
        // Timing
        maxImbalanceTime: 5000,
        idealRectCount: 5
    };

    // Active config (mutable)
    let CONFIG = { ...DEFAULT_CONFIG };

    // Legacy accessors for compatibility
    const getConfig = () => CONFIG;

    // Merge constants
    const BASE_EDGE_TOL = 20;
    const BASE_MAX_MERGE_AREA = 0.34;

    // Colors with weights from spec
    const COLORS = {
        RED:    { h: 4,   s: 85, l: 50, weight: 1.3 },
        BLUE:   { h: 220, s: 75, l: 35, weight: 1.1 },
        YELLOW: { h: 48,  s: 95, l: 55, weight: 0.9 },
        WHITE:  { h: 45,  s: 12, l: 96, weight: 0.6 }
    };

    // State bands (computed from config)
    const BANDS = {
        STABLE:   { min: 0, get max() { return CONFIG.bandStable; } },
        TENSION:  { get min() { return CONFIG.bandStable; }, get max() { return CONFIG.bandTension; } },
        WARNING:  { get min() { return CONFIG.bandTension; }, get max() { return CONFIG.bandWarning; } },
        COLLAPSE: { get min() { return CONFIG.bandWarning; }, max: 1.0 }
    };

    // === DOM ELEMENTS ===
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const failScreen = document.getElementById('failure-screen');
    const container = document.getElementById('game-container');
    const restartBtn = document.getElementById('restart-btn');

    canvas.width = SIZE;
    canvas.height = SIZE;

    // === GAME STATE ===
    let rectangles = [];
    let state = {
        isGameOver: false,
        draggedLine: null,
        hoveredLine: null,
        hoveredRect: null,
        mergeCandidate: null,
        lastTime: 0,
        balanceScore: 0.45,
        rawBalance: 0.45,
        stressDuration: 0,
        localStress: 0,
        elapsedTime: 0,
        driftScale: 0,
        comX: SIZE / 2,
        comY: SIZE / 2
    };

    // === RECTANGLE CLASS ===
    class Rectangle {
        constructor(x, y, w, h, colorKey) {
            this.x = x;
            this.y = y;
            this.w = w;
            this.h = h;
            this.colorKey = colorKey;
            this.localStress = 0;
            // Render positions for smooth animation
            this.rx = x;
            this.ry = y;
            this.rw = w;
            this.rh = h;
        }

        get area() {
            return this.w * this.h;
        }

        get weight() {
            return COLORS[this.colorKey].weight;
        }

        get mass() {
            return this.area * this.weight;
        }

        get centerX() {
            return this.x + this.w / 2;
        }

        get centerY() {
            return this.y + this.h / 2;
        }

        update(dt) {
            const lerp = Math.min(1, dt * 0.008);
            this.rx += (this.x - this.rx) * lerp;
            this.ry += (this.y - this.ry) * lerp;
            this.rw += (this.w - this.rw) * lerp;
            this.rh += (this.h - this.rh) * lerp;
        }

        contains(px, py) {
            return px >= this.x && px < this.x + this.w &&
                   py >= this.y && py < this.y + this.h;
        }
    }

    // === LINE STRUCTURE ===
    // Lines are derived from rectangle edges
    // Groups edges within SNAP_TOLERANCE to form unified lines
    const SNAP_TOLERANCE = 3;

    function getLines() {
        const hEdges = []; // {pos, rect, edge}
        const vEdges = [];

        rectangles.forEach(r => {
            if (r.y > 1 && r.y < SIZE - 1) {
                hEdges.push({ pos: r.y, rect: r, edge: 'top' });
            }
            const bottom = r.y + r.h;
            if (bottom > 1 && bottom < SIZE - 1) {
                hEdges.push({ pos: bottom, rect: r, edge: 'bottom' });
            }
            if (r.x > 1 && r.x < SIZE - 1) {
                vEdges.push({ pos: r.x, rect: r, edge: 'left' });
            }
            const right = r.x + r.w;
            if (right > 1 && right < SIZE - 1) {
                vEdges.push({ pos: right, rect: r, edge: 'right' });
            }
        });

        // Group edges within tolerance
        function groupEdges(edges) {
            if (edges.length === 0) return [];
            edges.sort((a, b) => a.pos - b.pos);

            const groups = [];
            let currentGroup = [edges[0]];

            for (let i = 1; i < edges.length; i++) {
                if (edges[i].pos - currentGroup[0].pos < SNAP_TOLERANCE) {
                    currentGroup.push(edges[i]);
                } else {
                    groups.push(currentGroup);
                    currentGroup = [edges[i]];
                }
            }
            groups.push(currentGroup);
            return groups;
        }

        const lines = [];
        groupEdges(hEdges).forEach(group => {
            const avgPos = group.reduce((s, e) => s + e.pos, 0) / group.length;
            lines.push({
                pos: avgPos,
                type: 'h',
                rects: group.map(e => ({ rect: e.rect, edge: e.edge })),
                renderPos: avgPos
            });
        });
        groupEdges(vEdges).forEach(group => {
            const avgPos = group.reduce((s, e) => s + e.pos, 0) / group.length;
            lines.push({
                pos: avgPos,
                type: 'v',
                rects: group.map(e => ({ rect: e.rect, edge: e.edge })),
                renderPos: avgPos
            });
        });

        return lines;
    }

    // Get line segments - only where rectangle edges actually exist
    function getLineSegments() {
        const segments = [];

        rectangles.forEach(r => {
            // Top edge (horizontal line)
            if (r.y > 1) {
                segments.push({ type: 'h', pos: r.y, start: r.x, end: r.x + r.w });
            }
            // Bottom edge (horizontal line)
            if (r.y + r.h < SIZE - 1) {
                segments.push({ type: 'h', pos: r.y + r.h, start: r.x, end: r.x + r.w });
            }
            // Left edge (vertical line)
            if (r.x > 1) {
                segments.push({ type: 'v', pos: r.x, start: r.y, end: r.y + r.h });
            }
            // Right edge (vertical line)
            if (r.x + r.w < SIZE - 1) {
                segments.push({ type: 'v', pos: r.x + r.w, start: r.y, end: r.y + r.h });
            }
        });

        // Merge overlapping segments at the same position
        const merged = [];
        const processed = new Set();

        segments.forEach((seg, i) => {
            if (processed.has(i)) return;

            let current = { ...seg };
            processed.add(i);

            // Find overlapping segments at same position and type
            segments.forEach((other, j) => {
                if (i === j || processed.has(j)) return;
                if (other.type !== seg.type) return;
                if (Math.abs(other.pos - seg.pos) > 1) return;

                // Check if segments overlap or are adjacent
                if (other.start <= current.end + 1 && other.end >= current.start - 1) {
                    current.start = Math.min(current.start, other.start);
                    current.end = Math.max(current.end, other.end);
                    processed.add(j);
                }
            });

            merged.push(current);
        });

        return merged;
    }

    // === BALANCE CALCULATION ===
    // Calculate local stress for each rectangle
    function calculateLocalStress(r, comX, comY, colorAreas) {
        // Area dominance - larger rectangles are more stressed
        const areaDominance = r.area / TOTAL_AREA;

        // Edge proximity - rectangles near edges feel more pressure
        const distToEdge = Math.min(r.x, r.y, SIZE - (r.x + r.w), SIZE - (r.y + r.h));
        const edgeProximity = 1 - Math.min(1, distToEdge / (SIZE * 0.2));

        // Color weight contribution
        const colorWeight = r.weight / 1.3; // normalized to max weight

        // Proximity to center of mass - rectangles far from COM are stressed
        const distToCOM = Math.sqrt(Math.pow(r.centerX - comX, 2) + Math.pow(r.centerY - comY, 2));
        const comProximity = Math.min(1, distToCOM / (SIZE * 0.4));

        // Color overrepresentation
        const idealColorArea = TOTAL_AREA / 4;
        const colorOverrep = Math.max(0, (colorAreas[r.colorKey] - idealColorArea) / idealColorArea);

        return (areaDominance * 0.25 + edgeProximity * 0.25 + colorWeight * 0.2 +
                comProximity * 0.15 + colorOverrep * 0.15);
    }

    function calculateBalance() {
        if (rectangles.length === 0) return 0.5;

        // Calculate color areas and total mass
        const colorAreas = { RED: 0, BLUE: 0, YELLOW: 0, WHITE: 0 };
        let totalWeightedArea = 0;

        rectangles.forEach(r => {
            colorAreas[r.colorKey] += r.area;
            totalWeightedArea += r.mass;
        });

        // Calculate center of mass
        let momentX = 0, momentY = 0;
        rectangles.forEach(r => {
            momentX += r.mass * r.centerX;
            momentY += r.mass * r.centerY;
        });
        const comX = momentX / totalWeightedArea;
        const comY = momentY / totalWeightedArea;

        // Store COM for drift calculations
        state.comX = comX;
        state.comY = comY;

        // Calculate and store local stress for each rectangle
        rectangles.forEach(r => {
            r.localStress = calculateLocalStress(r, comX, comY, colorAreas);
        });

        // 1. Color area imbalance (0.30)
        // Any color dominating is bad - use deviation squared for stronger penalty
        const idealShare = TOTAL_AREA / 4;
        let colorImbalance = 0;
        Object.keys(COLORS).forEach(c => {
            const share = colorAreas[c] / TOTAL_AREA;
            const deviation = Math.abs(share - 0.25);
            // Penalize over-representation more than under-representation
            // Weight affects how much that color's imbalance matters
            const overPenalty = share > 0.25 ? deviation * 1.5 : deviation;
            colorImbalance += overPenalty * (0.5 + COLORS[c].weight * 0.5);
        });
        // Scale so that major imbalance (one color at 60%+) pushes toward 1
        colorImbalance = Math.min(1, colorImbalance * 1.8);

        // 2. Centre of mass tension (0.25)
        // More sensitive - 80px offset = full tension
        const comDist = Math.sqrt(Math.pow(comX - SIZE/2, 2) + Math.pow(comY - SIZE/2, 2));
        const comTension = Math.min(1, comDist / (SIZE * 0.12));

        // 3. Edge pressure (0.20)
        let edgePressure = 0;
        rectangles.forEach(r => {
            const distToEdge = Math.min(
                r.x, r.y,
                SIZE - (r.x + r.w),
                SIZE - (r.y + r.h)
            );
            if (distToEdge < SIZE * 0.15) {
                const pressure = (r.mass / TOTAL_AREA) * (1 - distToEdge / (SIZE * 0.15));
                edgePressure += pressure;
            }
        });
        edgePressure = Math.min(1, edgePressure * 2);

        // 4. Complexity (0.20) - more fragmentation = worse balance
        // Ideal is 5-6 rectangles; excess rectangles penalized more than deficit
        const idealCount = CONFIG.idealRectCount;
        const count = rectangles.length;
        let complexityPenalty;
        if (count <= idealCount) {
            // Slightly penalize having too few (merged everything)
            complexityPenalty = (idealCount - count) * 0.08;
        } else {
            // Heavily penalize fragmentation
            complexityPenalty = (count - idealCount) * 0.1;
        }
        complexityPenalty = Math.min(1, complexityPenalty);

        // 5. Compression penalty - rectangles squashed near MIN_RECT_DIM create pressure
        let compressionPenalty = 0;
        const compressionThreshold = MIN_RECT_DIM * 2.5; // 50px
        rectangles.forEach(r => {
            const minDim = Math.min(r.w, r.h);
            if (minDim < compressionThreshold) {
                // How compressed is it? 1.0 = at minimum, 0 = at threshold
                const compressionRatio = 1 - (minDim - MIN_RECT_DIM) / (compressionThreshold - MIN_RECT_DIM);
                // Heavier colors under compression create more pressure
                const pressure = compressionRatio * compressionRatio * COLORS[r.colorKey].weight;
                compressionPenalty += pressure;
                // Store compression for drift calculations
                r.compression = compressionRatio;
            } else {
                r.compression = 0;
            }
        });
        compressionPenalty = Math.min(1, compressionPenalty * 0.5);
        state.compressionPenalty = compressionPenalty;

        // Combine components
        const rawScore =
            CONFIG.wColor * colorImbalance +
            CONFIG.wCom * comTension +
            CONFIG.wEdge * edgePressure +
            CONFIG.wComplexity * complexityPenalty +
            compressionPenalty * CONFIG.wCompression + // Compression adds significant pressure
            state.localStress * 0.3;

        return Math.min(1, Math.max(0, rawScore));
    }

    function getStateBand(score) {
        if (score < BANDS.STABLE.max) return 'STABLE';
        if (score < BANDS.TENSION.max) return 'TENSION';
        if (score < BANDS.WARNING.max) return 'WARNING';
        return 'COLLAPSE';
    }

    // Map balance score to 0-1 for visual effects
    function getImbalanceScale(score) {
        return Math.max(0, Math.min(1, (score - 0.48) / 0.20));
    }

    // === MERGE LOGIC ===
    function findMergePartner(rect) {
        if (!rect) return null;

        const stressBias = Math.min(1, state.balanceScore / 0.6);
        const edgeTol = BASE_EDGE_TOL + stressBias * 30;
        const maxMergeArea = TOTAL_AREA * (BASE_MAX_MERGE_AREA + stressBias * 0.35);

        for (const other of rectangles) {
            if (other === rect) continue;
            if (other.colorKey !== rect.colorKey) continue;
            if (rect.area + other.area > maxMergeArea) continue;

            // Check if rectangles share an edge (within tolerance)
            const rightTouch = Math.abs((rect.x + rect.w) - other.x) < edgeTol;
            const leftTouch = Math.abs((other.x + other.w) - rect.x) < edgeTol;
            const bottomTouch = Math.abs((rect.y + rect.h) - other.y) < edgeTol;
            const topTouch = Math.abs((other.y + other.h) - rect.y) < edgeTol;

            // For horizontal adjacency, check vertical overlap
            if (rightTouch || leftTouch) {
                const overlapStart = Math.max(rect.y, other.y);
                const overlapEnd = Math.min(rect.y + rect.h, other.y + other.h);
                const overlap = overlapEnd - overlapStart;
                const minHeight = Math.min(rect.h, other.h);
                // Require at least 30% overlap
                if (overlap > minHeight * 0.3) {
                    // Check if bounding box would overlap with other rects of different color
                    const bbox = {
                        x: Math.min(rect.x, other.x),
                        y: Math.min(rect.y, other.y),
                        w: Math.max(rect.x + rect.w, other.x + other.w) - Math.min(rect.x, other.x),
                        h: Math.max(rect.y + rect.h, other.y + other.h) - Math.min(rect.y, other.y)
                    };
                    if (!wouldOverlapOthers(bbox, rect, other)) {
                        return other;
                    }
                }
            }

            // For vertical adjacency, check horizontal overlap
            if (bottomTouch || topTouch) {
                const overlapStart = Math.max(rect.x, other.x);
                const overlapEnd = Math.min(rect.x + rect.w, other.x + other.w);
                const overlap = overlapEnd - overlapStart;
                const minWidth = Math.min(rect.w, other.w);
                // Require at least 30% overlap
                if (overlap > minWidth * 0.3) {
                    // Check if bounding box would overlap with other rects of different color
                    const bbox = {
                        x: Math.min(rect.x, other.x),
                        y: Math.min(rect.y, other.y),
                        w: Math.max(rect.x + rect.w, other.x + other.w) - Math.min(rect.x, other.x),
                        h: Math.max(rect.y + rect.h, other.y + other.h) - Math.min(rect.y, other.y)
                    };
                    if (!wouldOverlapOthers(bbox, rect, other)) {
                        return other;
                    }
                }
            }
        }

        return null;
    }

    function wouldOverlapOthers(bbox, except1, except2) {
        const margin = 2; // Small margin to avoid floating point issues
        for (const r of rectangles) {
            if (r === except1 || r === except2) continue;
            // Check if bbox overlaps with r
            const overlapsX = bbox.x < r.x + r.w - margin && bbox.x + bbox.w > r.x + margin;
            const overlapsY = bbox.y < r.y + r.h - margin && bbox.y + bbox.h > r.y + margin;
            if (overlapsX && overlapsY) {
                return true;
            }
        }
        return false;
    }

    function mergeRectangles(a, b) {
        const newX = Math.min(a.x, b.x);
        const newY = Math.min(a.y, b.y);
        const newW = Math.max(a.x + a.w, b.x + b.w) - newX;
        const newH = Math.max(a.y + a.h, b.y + b.h) - newY;

        rectangles = rectangles.filter(r => r !== a && r !== b);
        const merged = new Rectangle(newX, newY, newW, newH, a.colorKey);
        merged.rx = newX;
        merged.ry = newY;
        merged.rw = newW;
        merged.rh = newH;
        rectangles.push(merged);

        state.localStress = Math.max(0, state.localStress - 0.15);
        state.hoveredRect = null;
        state.mergeCandidate = null;
    }

    // === SPLIT LOGIC ===
    // If a line is hovered, split in that orientation; otherwise auto-detect
    function splitLargest() {
        const eligible = rectangles.filter(r => r.area >= TOTAL_AREA * 0.12);
        if (eligible.length === 0) return;

        const target = eligible.reduce((a, b) => a.area > b.area ? a : b);

        // Use hovered line orientation if available, otherwise auto-detect from target shape
        let splitVertical;
        if (state.hoveredLine) {
            splitVertical = state.hoveredLine.type === 'v';
        } else {
            splitVertical = target.w > target.h;
        }

        // Determine split position
        const splitPos = splitVertical
            ? target.x + target.w * 0.5
            : target.y + target.h * 0.5;

        // Split ALL rectangles that this line passes through
        const newRects = [];
        rectangles.forEach(r => {
            if (splitVertical) {
                // Vertical line at splitPos - split rects where splitPos is inside
                if (splitPos > r.x + MIN_RECT_DIM && splitPos < r.x + r.w - MIN_RECT_DIM) {
                    const left = new Rectangle(r.x, r.y, splitPos - r.x, r.h, r.colorKey);
                    const right = new Rectangle(splitPos, r.y, r.x + r.w - splitPos, r.h,
                        r === target ? 'WHITE' : r.colorKey);
                    left.rx = left.x; left.ry = left.y; left.rw = left.w; left.rh = left.h;
                    right.rx = right.x; right.ry = right.y; right.rw = right.w; right.rh = right.h;
                    newRects.push(left, right);
                } else {
                    newRects.push(r);
                }
            } else {
                // Horizontal line at splitPos - split rects where splitPos is inside
                if (splitPos > r.y + MIN_RECT_DIM && splitPos < r.y + r.h - MIN_RECT_DIM) {
                    const top = new Rectangle(r.x, r.y, r.w, splitPos - r.y, r.colorKey);
                    const bottom = new Rectangle(r.x, splitPos, r.w, r.y + r.h - splitPos,
                        r === target ? 'WHITE' : r.colorKey);
                    top.rx = top.x; top.ry = top.y; top.rw = top.w; top.rh = top.h;
                    bottom.rx = bottom.x; bottom.ry = bottom.y; bottom.rw = bottom.w; bottom.rh = bottom.h;
                    newRects.push(top, bottom);
                } else {
                    newRects.push(r);
                }
            }
        });

        rectangles = newRects;
        state.localStress += 0.2;
    }

    // === LINE MOVEMENT ===
    function moveLine(line, delta) {
        if (Math.abs(delta) < 0.01) return false; // Very low threshold

        const newPos = Math.max(MIN_RECT_DIM, Math.min(SIZE - MIN_RECT_DIM, line.pos + delta));

        // Check if move is valid (all rectangles stay >= MIN_RECT_DIM)
        let valid = true;
        line.rects.forEach(({ rect, edge }) => {
            // Calculate what the new edge position would be
            const currentEdgePos = line.type === 'h'
                ? (edge === 'top' ? rect.y : rect.y + rect.h)
                : (edge === 'left' ? rect.x : rect.x + rect.w);
            const edgeDelta = newPos - currentEdgePos;

            if (line.type === 'h') {
                if (edge === 'top') {
                    if (rect.h - edgeDelta < MIN_RECT_DIM) valid = false;
                } else {
                    if (rect.h + edgeDelta < MIN_RECT_DIM) valid = false;
                }
            } else {
                if (edge === 'left') {
                    if (rect.w - edgeDelta < MIN_RECT_DIM) valid = false;
                } else {
                    if (rect.w + edgeDelta < MIN_RECT_DIM) valid = false;
                }
            }
        });

        if (!valid) return false;

        // Apply the move - snap all edges to exactly newPos
        line.rects.forEach(({ rect, edge }) => {
            if (line.type === 'h') {
                if (edge === 'top') {
                    const oldY = rect.y;
                    rect.y = newPos;
                    rect.h += oldY - newPos;
                } else {
                    rect.h = newPos - rect.y;
                }
            } else {
                if (edge === 'left') {
                    const oldX = rect.x;
                    rect.x = newPos;
                    rect.w += oldX - newPos;
                } else {
                    rect.w = newPos - rect.x;
                }
            }
        });

        line.pos = newPos;
        return true;
    }

    // === PASSIVE DRIFT ===
    // Entropy creates gradual destabilization
    // - Time factor: drift slowly increases over time
    // - When balanced: minimal drift
    // - When imbalanced: drift accelerates
    function applyDrift(dt) {
        if (state.elapsedTime < CONFIG.driftStartTime) return;

        // Base time factor - reaches full strength over ramp time
        const timeFactor = Math.min(1, (state.elapsedTime - CONFIG.driftStartTime) / CONFIG.driftRampTime);

        // Imbalance factor: scales from minFactor (when balanced) to maxFactor (when imbalanced)
        // Uses configurable thresholds based on bands
        const minF = CONFIG.driftMinFactor;
        const maxF = CONFIG.driftMaxFactor;
        const stableMax = CONFIG.bandStable;
        const tensionMax = CONFIG.bandTension;

        let imbalanceFactor;
        if (state.balanceScore < stableMax * 0.6) {
            // Well balanced - minimal drift (respite)
            imbalanceFactor = minF + state.balanceScore * minF;
        } else if (state.balanceScore < stableMax) {
            // Good balance - gentle drift
            const t = (state.balanceScore - stableMax * 0.6) / (stableMax * 0.4);
            imbalanceFactor = minF * 2 + t * (0.4 - minF * 2);
        } else if (state.balanceScore < tensionMax) {
            // Tension - moderate drift
            const t = (state.balanceScore - stableMax) / (tensionMax - stableMax);
            imbalanceFactor = 0.4 + t * 0.4;
        } else {
            // Warning/Collapse - accelerating drift
            const t = Math.min(1, (state.balanceScore - tensionMax) / 0.2);
            imbalanceFactor = 0.8 + t * (maxF - 0.8);
        }

        state.driftScale = timeFactor * imbalanceFactor;

        const lines = getLines();
        if (lines.length === 0) return;

        // Track time since last successful drift to prevent stagnation
        if (!state.lastDriftTime) state.lastDriftTime = state.elapsedTime;
        const timeSinceDrift = state.elapsedTime - state.lastDriftTime;

        // Stagnation multiplier - increases if no drift has happened recently
        const stagnationBoost = 1 + Math.min(3, timeSinceDrift / 10);

        // Pick one random line to drift each frame
        const line = lines[Math.floor(Math.random() * lines.length)];

        // Calculate directional bias:
        // Heavier rectangles (RED, BLUE) should grow, lighter (WHITE) should shrink
        let heavyPressure = 0;
        line.rects.forEach(({ rect, edge }) => {
            const weight = COLORS[rect.colorKey].weight;
            const direction = (weight > 1) ? 1 : -0.5;
            if (line.type === 'h') {
                heavyPressure += (edge === 'bottom' ? 1 : -1) * direction;
            } else {
                heavyPressure += (edge === 'right' ? 1 : -1) * direction;
            }
        });

        // Add stress-based pressure (stressed rects push outward)
        let stressPressure = 0;
        line.rects.forEach(({ rect, edge }) => {
            const stress = rect.localStress || 0;
            if (line.type === 'h') {
                stressPressure += (edge === 'top' ? -1 : 1) * stress;
            } else {
                stressPressure += (edge === 'left' ? -1 : 1) * stress;
            }
        });

        // Add compression-based pressure (squashed rects push back hard)
        let compressionPressure = 0;
        line.rects.forEach(({ rect, edge }) => {
            const compression = rect.compression || 0;
            if (compression > 0) {
                // Compressed rect pushes OUTWARD from its compressed dimension
                const isCompressedDim = (line.type === 'h' && rect.h < rect.w) ||
                                        (line.type === 'v' && rect.w < rect.h);
                if (isCompressedDim) {
                    // Push away from this rect (expand it)
                    if (line.type === 'h') {
                        compressionPressure += (edge === 'top' ? -1 : 1) * compression * 2;
                    } else {
                        compressionPressure += (edge === 'left' ? -1 : 1) * compression * 2;
                    }
                }
            }
        });

        // Guaranteed periodic nudge every ~5 seconds to prevent total stagnation
        const periodicNudge = (Math.sin(state.elapsedTime * 0.2) > 0.9) ?
            (Math.random() > 0.5 ? 1 : -1) * 0.8 : 0;

        // Combine: bias + stress + compression + noise + periodic nudge
        // Noise biased toward expansion, boosted by stagnation
        const baseNoise = (Math.random() - 0.25) * 0.8 * stagnationBoost;
        const drift = (heavyPressure * 0.5 + stressPressure * 1.0 + compressionPressure * 1.5 + baseNoise + periodicNudge) * state.driftScale;

        // Apply drift
        if (Math.abs(drift) > 0.02) {
            const moved = moveLine(line, drift);
            if (moved) {
                state.lastDriftTime = state.elapsedTime;
            }
        }
    }

    // === UPDATE ===
    function update(dt) {
        if (state.isGameOver) return;

        state.elapsedTime += dt / 1000;
        state.localStress = Math.max(0, state.localStress - dt * 0.0003);

        // Apply drift
        applyDrift(dt);

        // Update rectangle animations
        rectangles.forEach(r => r.update(dt));

        // Calculate balance
        state.rawBalance = calculateBalance();
        // Faster response to imbalance changes
        state.balanceScore += (state.rawBalance - state.balanceScore) * Math.min(1, dt * 0.008);

        // Check for collapse
        // COLLAPSE band (>0.75): fast collapse (5 seconds)
        // WARNING band (0.65-0.75): slow collapse (15 seconds)
        if (state.balanceScore > BANDS.WARNING.max) {
            // In COLLAPSE - accumulate stress quickly
            state.stressDuration += dt;
            if (state.stressDuration > CONFIG.maxImbalanceTime) {
                state.isGameOver = true;
                failScreen.style.display = 'flex';
            }
        } else if (state.balanceScore > BANDS.TENSION.max) {
            // In WARNING - accumulate stress slowly (3x longer to collapse)
            state.stressDuration += dt * 0.33;
            if (state.stressDuration > CONFIG.maxImbalanceTime) {
                state.isGameOver = true;
                failScreen.style.display = 'flex';
            }
        } else {
            // Recovering - stress decreases
            state.stressDuration = Math.max(0, state.stressDuration - dt * 1.5);
        }
    }

    // === DRAW ===
    // Visual feedback is subtle, cumulative, and diegetic
    // The painting reacts to imbalance like a physical object under stress
    function draw() {
        const imb = getImbalanceScale(state.balanceScore);
        const band = getStateBand(state.balanceScore);

        // Calculate color areas for saturation drift
        const colorAreas = { RED: 0, BLUE: 0, YELLOW: 0, WHITE: 0 };
        rectangles.forEach(r => colorAreas[r.colorKey] += r.area);
        const idealArea = TOTAL_AREA / 4;

        // Background - becomes slightly warmer/deader with stress
        const bgLight = 99 - imb * 3;
        ctx.fillStyle = `hsl(45, ${5 + imb * 3}%, ${bgLight}%)`;
        ctx.fillRect(0, 0, SIZE, SIZE);

        // Micro-motion: extremely slow drift, almost imperceptible
        // Freezes abruptly on collapse
        let offsetX = 0, offsetY = 0;
        if (band !== 'COLLAPSE' && band !== 'STABLE') {
            const freq = 0.15; // Very slow
            const magnitude = imb * 1.5;
            offsetX = Math.sin(state.elapsedTime * freq) * magnitude;
            offsetY = Math.cos(state.elapsedTime * freq * 0.7) * magnitude;
        }

        // Draw rectangles with stress-based color
        rectangles.forEach(r => {
            const base = COLORS[r.colorKey];
            const stress = r.localStress || 0;

            // Color saturation drift based on over/under-representation
            const colorRatio = colorAreas[r.colorKey] / idealArea;
            let satMod = 1;
            let lightMod = 1;

            if (band !== 'STABLE') {
                if (colorRatio > 1) {
                    // Overrepresented: oversaturate slightly, feels heavy
                    satMod = 1 + (colorRatio - 1) * 0.15 * imb;
                    if (r.colorKey === 'RED') lightMod = 1 - imb * 0.1; // Reds darken
                } else {
                    // Underrepresented: desaturate, loses vibrancy
                    satMod = 1 - (1 - colorRatio) * 0.2 * imb;
                }
                // White warms slightly under tension
                if (r.colorKey === 'WHITE' && band !== 'STABLE') {
                    satMod = 1 + imb * 0.3;
                }
            }

            // Collapse: all colors dull toward grey
            if (band === 'COLLAPSE') {
                satMod *= (1 - imb * 0.5);
                lightMod *= (1 - imb * 0.15);
            }

            const s = Math.min(100, base.s * satMod);
            const l = Math.max(20, Math.min(98, base.l * lightMod));

            ctx.fillStyle = `hsl(${base.h}, ${s}%, ${l}%)`;
            ctx.fillRect(r.rx + offsetX, r.ry + offsetY, r.rw, r.rh);

            // Pressure shading on stressed rectangles (subtle vignette)
            if (stress > 0.3 && band !== 'STABLE') {
                const grad = ctx.createRadialGradient(
                    r.rx + r.rw/2, r.ry + r.rh/2, 0,
                    r.rx + r.rw/2, r.ry + r.rh/2, Math.max(r.rw, r.rh) * 0.8
                );
                grad.addColorStop(0, 'transparent');
                grad.addColorStop(1, `rgba(0,0,0,${stress * imb * 0.08})`);
                ctx.fillStyle = grad;
                ctx.fillRect(r.rx + offsetX, r.ry + offsetY, r.rw, r.rh);
            }
        });

        // Highlight merge candidates (subtle, not pulsing)
        if (state.hoveredRect && state.mergeCandidate) {
            [state.hoveredRect, state.mergeCandidate].forEach(r => {
                ctx.strokeStyle = 'rgba(26, 26, 26, 0.4)';
                ctx.lineWidth = 3;
                ctx.strokeRect(r.rx + 5 + offsetX, r.ry + 5 + offsetY, r.rw - 10, r.rh - 10);
            });
        }

        // Draw lines with stress-based thickness
        // Lines behave like structural beams under load
        const baseThickness = 6;
        const lines = getLines();

        // Get line segments for drawing
        const segments = getLineSegments();

        segments.forEach(seg => {
            // Find local stress for this line segment
            let localLineStress = 0;
            let stressCount = 0;
            rectangles.forEach(r => {
                // Check if this rectangle touches this line segment
                const touches = seg.type === 'h'
                    ? (Math.abs(r.y - seg.pos) < 2 || Math.abs(r.y + r.h - seg.pos) < 2)
                    : (Math.abs(r.x - seg.pos) < 2 || Math.abs(r.x + r.w - seg.pos) < 2);
                if (touches) {
                    localLineStress += r.localStress || 0;
                    stressCount++;
                }
            });
            localLineStress = stressCount > 0 ? localLineStress / stressCount : 0;

            // Line thickness varies with local stress
            const stressThickness = baseThickness * (1 + localLineStress * imb * 2);

            const isHovered = state.hoveredLine &&
                Math.abs(state.hoveredLine.pos - seg.pos) < SNAP_TOLERANCE &&
                state.hoveredLine.type === seg.type;
            const isDragged = state.draggedLine &&
                Math.abs(state.draggedLine.pos - seg.pos) < SNAP_TOLERANCE &&
                state.draggedLine.type === seg.type;

            // Lines darken slightly under stress
            const darkness = 0.92 + localLineStress * imb * 0.08;
            ctx.fillStyle = (isHovered || isDragged)
                ? `hsl(0, 60%, 45%)`
                : `rgba(26, 26, 26, ${darkness})`;

            if (seg.type === 'h') {
                ctx.fillRect(
                    seg.start + offsetX,
                    seg.pos - stressThickness/2 + offsetY,
                    seg.end - seg.start,
                    stressThickness
                );
            } else {
                ctx.fillRect(
                    seg.pos - stressThickness/2 + offsetX,
                    seg.start + offsetY,
                    stressThickness,
                    seg.end - seg.start
                );
            }
        });

        // Global vignette on high imbalance (canvas feels constricted)
        if (imb > 0.2) {
            const grad = ctx.createRadialGradient(
                SIZE/2, SIZE/2, SIZE * 0.3,
                SIZE/2, SIZE/2, SIZE * 0.8
            );
            grad.addColorStop(0, 'transparent');
            grad.addColorStop(1, `rgba(0,0,0,${imb * 0.08})`);
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, SIZE, SIZE);
        }

        // No container shake - stillness on collapse feels wrong (per spec)
        container.style.transform = 'none';

        // Update debug panel
        updateDebugPanel();
    }

    // === DEBUG PANEL ===
    const debugPanel = document.getElementById('debug-panel');
    let debugVisible = false;

    function updateDebugPanel() {
        if (!debugVisible) return;

        const band = getStateBand(state.balanceScore);
        const comDist = Math.sqrt(Math.pow(state.comX - SIZE/2, 2) + Math.pow(state.comY - SIZE/2, 2));

        // Calculate color areas
        const colorAreas = { RED: 0, BLUE: 0, YELLOW: 0, WHITE: 0 };
        let avgStress = 0;
        rectangles.forEach(r => {
            colorAreas[r.colorKey] += r.area;
            avgStress += r.localStress || 0;
        });
        avgStress = rectangles.length > 0 ? avgStress / rectangles.length : 0;

        // Update elements
        document.getElementById('dbg-time').textContent = state.elapsedTime.toFixed(1) + 's';
        document.getElementById('dbg-band').textContent = band;
        document.getElementById('dbg-band').className = 'value ' +
            (band === 'STABLE' ? 'stable' : band === 'TENSION' ? 'warning' : band === 'WARNING' ? 'warning' : 'danger');

        document.getElementById('dbg-balance').textContent = state.balanceScore.toFixed(3);
        document.getElementById('dbg-raw').textContent = state.rawBalance.toFixed(3);
        document.getElementById('dbg-drift').textContent = state.driftScale.toFixed(3);
        document.getElementById('dbg-stress').textContent = Math.round(state.stressDuration) + 'ms';
        document.getElementById('dbg-com').textContent = comDist.toFixed(1) + 'px';
        document.getElementById('dbg-rects').textContent = rectangles.length;
        document.getElementById('dbg-local').textContent = avgStress.toFixed(3);
        document.getElementById('dbg-compress').textContent = (state.compressionPenalty || 0).toFixed(3);

        // Balance bar
        const barFill = document.getElementById('dbg-balance-bar');
        const pct = Math.min(100, state.balanceScore * 100);
        barFill.style.width = pct + '%';
        barFill.style.background = band === 'STABLE' ? '#0f0' :
            band === 'TENSION' ? '#ff0' : band === 'WARNING' ? '#f80' : '#f00';

        // Color areas
        document.getElementById('dbg-red').textContent = (colorAreas.RED / TOTAL_AREA * 100).toFixed(1) + '%';
        document.getElementById('dbg-blue').textContent = (colorAreas.BLUE / TOTAL_AREA * 100).toFixed(1) + '%';
        document.getElementById('dbg-yellow').textContent = (colorAreas.YELLOW / TOTAL_AREA * 100).toFixed(1) + '%';
        document.getElementById('dbg-white').textContent = (colorAreas.WHITE / TOTAL_AREA * 100).toFixed(1) + '%';
    }

    // Toggle debug panel with 'D' key
    window.addEventListener('keydown', e => {
        if (e.code === 'KeyD' && !e.ctrlKey && !e.metaKey) {
            debugVisible = !debugVisible;
            debugPanel.classList.toggle('visible', debugVisible);
        }
    });

    // === CONFIG PANEL ===
    const configPanel = document.getElementById('config-panel');
    let configVisible = false;
    let galleryOpen = false; // Defined here for use in config key handler

    function populateConfigPanel() {
        document.getElementById('cfg-w-color').value = CONFIG.wColor;
        document.getElementById('cfg-w-com').value = CONFIG.wCom;
        document.getElementById('cfg-w-edge').value = CONFIG.wEdge;
        document.getElementById('cfg-w-complexity').value = CONFIG.wComplexity;
        document.getElementById('cfg-w-compress').value = CONFIG.wCompression;
        document.getElementById('cfg-band-stable').value = CONFIG.bandStable;
        document.getElementById('cfg-band-tension').value = CONFIG.bandTension;
        document.getElementById('cfg-band-warning').value = CONFIG.bandWarning;
        document.getElementById('cfg-drift-start').value = CONFIG.driftStartTime;
        document.getElementById('cfg-drift-ramp').value = CONFIG.driftRampTime;
        document.getElementById('cfg-drift-min').value = CONFIG.driftMinFactor;
        document.getElementById('cfg-drift-max').value = CONFIG.driftMaxFactor;
        document.getElementById('cfg-collapse-time').value = CONFIG.maxImbalanceTime;
        document.getElementById('cfg-ideal-rects').value = CONFIG.idealRectCount;
    }

    function applyConfig() {
        CONFIG.wColor = parseFloat(document.getElementById('cfg-w-color').value);
        CONFIG.wCom = parseFloat(document.getElementById('cfg-w-com').value);
        CONFIG.wEdge = parseFloat(document.getElementById('cfg-w-edge').value);
        CONFIG.wComplexity = parseFloat(document.getElementById('cfg-w-complexity').value);
        CONFIG.wCompression = parseFloat(document.getElementById('cfg-w-compress').value);
        CONFIG.bandStable = parseFloat(document.getElementById('cfg-band-stable').value);
        CONFIG.bandTension = parseFloat(document.getElementById('cfg-band-tension').value);
        CONFIG.bandWarning = parseFloat(document.getElementById('cfg-band-warning').value);
        CONFIG.driftStartTime = parseFloat(document.getElementById('cfg-drift-start').value);
        CONFIG.driftRampTime = parseFloat(document.getElementById('cfg-drift-ramp').value);
        CONFIG.driftMinFactor = parseFloat(document.getElementById('cfg-drift-min').value);
        CONFIG.driftMaxFactor = parseFloat(document.getElementById('cfg-drift-max').value);
        CONFIG.maxImbalanceTime = parseFloat(document.getElementById('cfg-collapse-time').value);
        CONFIG.idealRectCount = parseInt(document.getElementById('cfg-ideal-rects').value);

        // Save to localStorage
        localStorage.setItem('balance_config', JSON.stringify(CONFIG));
    }

    function resetConfig() {
        CONFIG = { ...DEFAULT_CONFIG };
        populateConfigPanel();
        localStorage.removeItem('balance_config');
    }

    function loadSavedConfig() {
        try {
            const saved = localStorage.getItem('balance_config');
            if (saved) {
                const parsed = JSON.parse(saved);
                CONFIG = { ...DEFAULT_CONFIG, ...parsed };
            }
        } catch (e) {
            console.warn('Failed to load saved config:', e);
        }
    }

    // Load saved config on startup
    loadSavedConfig();
    populateConfigPanel();

    document.getElementById('cfg-apply').addEventListener('click', applyConfig);
    document.getElementById('cfg-reset').addEventListener('click', resetConfig);

    window.addEventListener('keydown', e => {
        if (e.code === 'KeyC' && !e.ctrlKey && !e.metaKey && !galleryOpen) {
            configVisible = !configVisible;
            configPanel.classList.toggle('visible', configVisible);
            if (configVisible) populateConfigPanel();
        }
    });

    // === SAVE/LOAD COMPOSITIONS ===
    const galleryOverlay = document.getElementById('gallery-overlay');
    const galleryGrid = document.getElementById('gallery-grid');
    const galleryClose = document.getElementById('gallery-close');
    const saveToast = document.getElementById('save-toast');
    const STORAGE_KEY = 'balance_saved_compositions';
    // galleryOpen is defined in config panel section above

    function getSavedCompositions() {
        try {
            return JSON.parse(localStorage.getItem(STORAGE_KEY)) || [];
        } catch {
            return [];
        }
    }

    function saveComposition() {
        const saved = getSavedCompositions();
        const composition = {
            id: Date.now(),
            date: new Date().toLocaleDateString(),
            time: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
            rectangles: rectangles.map(r => ({
                x: r.x, y: r.y, w: r.w, h: r.h, colorKey: r.colorKey
            })),
            balanceScore: state.balanceScore
        };
        saved.unshift(composition);
        // Keep only last 20 saves
        if (saved.length > 20) saved.pop();
        localStorage.setItem(STORAGE_KEY, JSON.stringify(saved));

        // Show toast
        saveToast.classList.add('visible');
        setTimeout(() => saveToast.classList.remove('visible'), 1500);
    }

    function deleteComposition(id) {
        let saved = getSavedCompositions();
        saved = saved.filter(c => c.id !== id);
        localStorage.setItem(STORAGE_KEY, JSON.stringify(saved));
        renderGallery();
    }

    function loadComposition(composition) {
        // Pause game and load the saved layout for viewing
        rectangles = composition.rectangles.map(r => {
            const rect = new Rectangle(r.x, r.y, r.w, r.h, r.colorKey);
            rect.rx = r.x; rect.ry = r.y; rect.rw = r.w; rect.rh = r.h;
            return rect;
        });
        closeGallery();
        // Reset game state but keep the loaded rectangles
        state.elapsedTime = 0;
        state.stressDuration = 0;
        state.localStress = 0;
        state.isGameOver = false;
        failScreen.style.display = 'none';
    }

    function renderCompositionThumbnail(composition, size = 150) {
        const thumbCanvas = document.createElement('canvas');
        thumbCanvas.width = size;
        thumbCanvas.height = size;
        const thumbCtx = thumbCanvas.getContext('2d');
        const scale = size / SIZE;

        // Draw rectangles
        composition.rectangles.forEach(r => {
            const color = COLORS[r.colorKey];
            thumbCtx.fillStyle = `hsl(${color.h}, ${color.s}%, ${color.l}%)`;
            thumbCtx.fillRect(r.x * scale, r.y * scale, r.w * scale, r.h * scale);
        });

        // Draw lines
        thumbCtx.fillStyle = '#1a1a1a';
        const lineWidth = 2;
        const edges = new Set();
        composition.rectangles.forEach(r => {
            edges.add(`h:${Math.round(r.y)}`);
            edges.add(`h:${Math.round(r.y + r.h)}`);
            edges.add(`v:${Math.round(r.x)}`);
            edges.add(`v:${Math.round(r.x + r.w)}`);
        });
        edges.forEach(edge => {
            const [type, pos] = edge.split(':');
            const p = parseInt(pos) * scale;
            if (type === 'h') {
                thumbCtx.fillRect(0, p - lineWidth/2, size, lineWidth);
            } else {
                thumbCtx.fillRect(p - lineWidth/2, 0, lineWidth, size);
            }
        });

        return thumbCanvas;
    }

    function renderGallery() {
        const saved = getSavedCompositions();
        galleryGrid.innerHTML = '';

        if (saved.length === 0) {
            galleryGrid.innerHTML = '<p class="gallery-empty">No saved compositions yet. Press S to save.</p>';
            return;
        }

        saved.forEach(composition => {
            const item = document.createElement('div');
            item.className = 'gallery-item';

            const thumb = renderCompositionThumbnail(composition);
            item.appendChild(thumb);

            const meta = document.createElement('div');
            meta.className = 'meta';
            meta.innerHTML = `
                <span>${composition.date} ${composition.time}</span>
                <button class="delete-btn" data-id="${composition.id}">&times;</button>
            `;
            item.appendChild(meta);

            thumb.addEventListener('click', () => loadComposition(composition));
            meta.querySelector('.delete-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                deleteComposition(composition.id);
            });

            galleryGrid.appendChild(item);
        });
    }

    function openGallery() {
        galleryOpen = true;
        renderGallery();
        galleryOverlay.classList.add('visible');
    }

    function closeGallery() {
        galleryOpen = false;
        galleryOverlay.classList.remove('visible');
    }

    galleryClose.addEventListener('click', closeGallery);

    window.addEventListener('keydown', e => {
        if (e.code === 'KeyS' && !e.ctrlKey && !e.metaKey && !galleryOpen) {
            saveComposition();
        }
        if (e.code === 'KeyG' && !e.ctrlKey && !e.metaKey) {
            if (galleryOpen) {
                closeGallery();
            } else {
                openGallery();
            }
        }
        if (e.code === 'Escape' && galleryOpen) {
            closeGallery();
        }
    });

    // === GAME LOOP ===
    function gameLoop(timestamp) {
        const dt = Math.min(50, timestamp - state.lastTime);
        state.lastTime = timestamp;

        update(dt);
        draw();

        requestAnimationFrame(gameLoop);
    }

    // === INPUT HANDLING ===
    function getMousePos(e) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = SIZE / rect.width;
        const scaleY = SIZE / rect.height;
        return {
            x: (e.clientX - rect.left) * scaleX,
            y: (e.clientY - rect.top) * scaleY
        };
    }

    function findLineAt(x, y, tolerance = 15) {
        const lines = getLines();
        for (const line of lines) {
            const dist = line.type === 'h' ? Math.abs(y - line.pos) : Math.abs(x - line.pos);
            if (dist < tolerance) {
                // Also check if cursor is within the line's extent
                // Find the range this line covers based on its rectangles
                let minPos = SIZE, maxPos = 0;
                line.rects.forEach(({ rect, edge }) => {
                    if (line.type === 'h') {
                        minPos = Math.min(minPos, rect.x);
                        maxPos = Math.max(maxPos, rect.x + rect.w);
                    } else {
                        minPos = Math.min(minPos, rect.y);
                        maxPos = Math.max(maxPos, rect.y + rect.h);
                    }
                });
                const alongPos = line.type === 'h' ? x : y;
                if (alongPos >= minPos - tolerance && alongPos <= maxPos + tolerance) {
                    return line;
                }
            }
        }
        return null;
    }

    function findRectAt(x, y) {
        for (const r of rectangles) {
            if (r.contains(x, y)) return r;
        }
        return null;
    }

    canvas.addEventListener('pointerdown', e => {
        if (state.isGameOver) return;
        e.preventDefault();

        const pos = getMousePos(e);
        const line = findLineAt(pos.x, pos.y, 20);
        if (line) {
            state.draggedLine = line;
            canvas.setPointerCapture(e.pointerId);
        }
    });

    canvas.addEventListener('pointermove', e => {
        const pos = getMousePos(e);

        // Update hover states
        state.hoveredLine = findLineAt(pos.x, pos.y);
        state.hoveredRect = findRectAt(pos.x, pos.y);

        if (state.hoveredRect) {
            state.mergeCandidate = findMergePartner(state.hoveredRect);
        } else {
            state.mergeCandidate = null;
        }

        // Handle drag
        if (state.draggedLine && !state.isGameOver) {
            const efficiency = state.balanceScore > 0.68 ? 0.4 : 1.0;
            const targetPos = state.draggedLine.type === 'h' ? pos.y : pos.x;
            const delta = (targetPos - state.draggedLine.pos) * efficiency;
            moveLine(state.draggedLine, delta);
        }
    });

    canvas.addEventListener('pointerup', e => {
        state.draggedLine = null;
        canvas.releasePointerCapture(e.pointerId);
    });

    canvas.addEventListener('pointerleave', () => {
        state.hoveredLine = null;
        state.hoveredRect = null;
        state.mergeCandidate = null;
    });

    canvas.addEventListener('dblclick', e => {
        if (state.isGameOver) return;
        e.preventDefault();

        const pos = getMousePos(e);
        const rect = findRectAt(pos.x, pos.y);
        const partner = rect ? findMergePartner(rect) : null;

        if (rect && partner) {
            mergeRectangles(rect, partner);
        }
    });

    window.addEventListener('keydown', e => {
        if (e.code === 'Space' && !state.isGameOver) {
            e.preventDefault();
            splitLargest();
        }
    });

    restartBtn.addEventListener('click', resetGame);

    // === RESET ===
    function resetGame() {
        state = {
            isGameOver: false,
            draggedLine: null,
            hoveredLine: null,
            hoveredRect: null,
            mergeCandidate: null,
            lastTime: performance.now(),
            balanceScore: 0.45,
            rawBalance: 0.45,
            stressDuration: 0,
            localStress: 0,
            elapsedTime: 0,
            driftScale: 0,
            comX: SIZE / 2,
            comY: SIZE / 2
        };

        failScreen.style.display = 'none';
        container.style.transform = 'none';

        // Starting layout from spec
        rectangles = [
            // Top row (h = 280)
            new Rectangle(0,   0,   230, 280, 'RED'),
            new Rectangle(230, 0,   130, 280, 'RED'),
            new Rectangle(360, 0,   120, 280, 'WHITE'),
            new Rectangle(480, 0,   120, 280, 'WHITE'),
            // Bottom row (h = 320)
            new Rectangle(0,   280, 200, 320, 'WHITE'),
            new Rectangle(200, 280, 160, 320, 'YELLOW'),
            new Rectangle(360, 280, 120, 320, 'YELLOW'),
            new Rectangle(480, 280, 120, 320, 'BLUE')
        ];

        // Initialize render positions
        rectangles.forEach(r => {
            r.rx = r.x; r.ry = r.y; r.rw = r.w; r.rh = r.h;
        });
    }

    // === INIT ===
    resetGame();
    requestAnimationFrame(gameLoop);

})();
</script>
</body>
</html>
